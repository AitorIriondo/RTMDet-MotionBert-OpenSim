<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Y-Bot Animation Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 1px solid #333;
        }
        .panel-header {
            background: #16213e;
            padding: 10px 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-content {
            flex: 1;
            position: relative;
            background: #0f0f1a;
        }
        #video-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #video {
            max-width: 100%;
            max-height: 100%;
        }
        #three-container {
            width: 100%;
            height: 100%;
        }
        .controls {
            background: #16213e;
            padding: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #ff6b6b;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        input[type="range"] {
            width: 300px;
        }
        select {
            background: #0f0f1a;
            color: #eee;
            border: 1px solid #333;
            padding: 8px;
            border-radius: 4px;
        }
        .time-display {
            font-family: monospace;
            font-size: 14px;
            min-width: 120px;
        }
        .status {
            font-size: 12px;
            color: #888;
        }
        .sync-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ecca3;
        }
        .sync-indicator.off {
            background: #e94560;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #e94560;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-info {
            font-size: 11px;
            color: #4ecca3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <div class="panel-header">
                <span>Original Video</span>
                <span class="file-info" id="video-info">-</span>
            </div>
            <div class="panel-content">
                <div id="video-container">
                    <video id="video" controls muted>
                        <source src="" type="video/mp4">
                    </video>
                </div>
            </div>
        </div>
        <div class="panel">
            <div class="panel-header">
                <span>Y-Bot Animation (GLB)</span>
                <span class="file-info" id="fbx-info">Loading...</span>
            </div>
            <div class="panel-content">
                <div id="three-container">
                    <div id="loading">
                        <div class="spinner"></div>
                        <div>Loading model...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="controls">
        <div class="control-group">
            <button id="play-btn">‚ñ∂ Play</button>
            <button id="pause-btn">‚è∏ Pause</button>
            <button id="reset-btn">‚èÆ Reset</button>
        </div>
        <div class="control-group">
            <span>Time:</span>
            <input type="range" id="timeline" min="0" max="100" value="0" step="0.1">
            <span class="time-display" id="time-display">0:00.00 / 0:00.00</span>
        </div>
        <div class="control-group">
            <span>Speed:</span>
            <select id="speed">
                <option value="0.25">0.25x</option>
                <option value="0.5">0.5x</option>
                <option value="1" selected>1x</option>
                <option value="1.5">1.5x</option>
                <option value="2">2x</option>
            </select>
        </div>
        <div class="control-group">
            <div class="sync-indicator" id="sync-indicator"></div>
            <span>Sync</span>
        </div>
        <div class="control-group">
            <button id="loop-btn">üîÅ Loop: OFF</button>
        </div>
        <div class="control-group">
            <button id="refresh-btn">üîÑ Load Latest</button>
        </div>
        <div class="control-group">
            <span class="status" id="status">Ready</span>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Elements
        const video = document.getElementById('video');
        const threeContainer = document.getElementById('three-container');
        const timeline = document.getElementById('timeline');
        const timeDisplay = document.getElementById('time-display');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedSelect = document.getElementById('speed');
        const refreshBtn = document.getElementById('refresh-btn');
        const loopBtn = document.getElementById('loop-btn');
        const statusEl = document.getElementById('status');
        const syncIndicator = document.getElementById('sync-indicator');
        const loadingEl = document.getElementById('loading');
        const videoInfo = document.getElementById('video-info');
        const fbxInfo = document.getElementById('fbx-info');

        // Three.js setup
        let scene, camera, renderer, controls;
        let mixer, animationAction;
        let isPlaying = false;
        let isLooping = false;
        let duration = 0;
        let currentFbxFile = '';

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f1a);

            camera = new THREE.PerspectiveCamera(45, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 4);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            threeContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ground grid
            const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = threeContainer.clientWidth / threeContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
        }

        async function loadModel(url) {
            loadingEl.style.display = 'block';
            statusEl.textContent = 'Loading model...';

            // Remove old model
            const toRemove = [];
            scene.children.forEach(child => {
                if (child.type === 'Group' || child.type === 'Object3D' || child.isObject3D && child.name !== '') {
                    if (child.type !== 'AmbientLight' && child.type !== 'DirectionalLight' && child.type !== 'GridHelper') {
                        toRemove.push(child);
                    }
                }
            });
            toRemove.forEach(child => scene.remove(child));

            const loader = new GLTFLoader();

            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(url, resolve,
                        (progress) => {
                            if (progress.total > 0) {
                                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                                statusEl.textContent = `Loading: ${percent}%`;
                            }
                        },
                        reject
                    );
                });

                const model = gltf.scene;

                // Setup animation
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    const clip = gltf.animations[0];

                    if (animationAction) {
                        animationAction.stop();
                    }

                    animationAction = mixer.clipAction(clip);
                    animationAction.setLoop(THREE.LoopOnce, 0);
                    animationAction.clampWhenFinished = true;
                    animationAction.enabled = true;
                    animationAction.setEffectiveWeight(1);
                    animationAction.setEffectiveTimeScale(1);
                    animationAction.play();

                    // Set to frame 0
                    animationTime = 0;
                    mixer.setTime(0);
                    isPlaying = false;

                    duration = clip.duration;
                    timeline.max = duration;

                    console.log('Animation loaded:', clip.name, 'Duration:', duration, 'Tracks:', clip.tracks.length);

                    // Fix duration if needed
                    const trackDurations = clip.tracks.map(t => t.times[t.times.length - 1]);
                    const maxTrackDuration = Math.max(...trackDurations);
                    if (Math.abs(clip.duration - maxTrackDuration) > 0.1) {
                        clip.duration = maxTrackDuration;
                        duration = maxTrackDuration;
                        timeline.max = duration;
                    }
                    statusEl.textContent = `Loaded: ${duration.toFixed(2)}s animation (${Math.round(duration * 30)} frames)`;
                } else {
                    statusEl.textContent = 'Warning: No animation found';
                }

                scene.add(model);
                loadingEl.style.display = 'none';

                const filename = url.split('/').pop();
                fbxInfo.textContent = filename;
                currentFbxFile = filename;

            } catch (error) {
                console.error('Error loading model:', error);
                statusEl.textContent = 'Error: ' + error.message;
                loadingEl.style.display = 'none';
            }
        }

        async function loadLatestModel() {
            try {
                const response = await fetch('/api/latest-model');
                const data = await response.json();

                if (data.file) {
                    await loadModel('/output/' + data.file);
                } else {
                    statusEl.textContent = 'No model files found';
                }
            } catch (error) {
                console.error('Error fetching latest model:', error);
                statusEl.textContent = 'Server not running - use file picker';
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${mins}:${secs.padStart(5, '0')}`;
        }

        function updateTimeDisplay() {
            // Always use our tracked time, not the action time
            const totalTime = duration || 0;
            timeDisplay.textContent = `${formatTime(animationTime)} / ${formatTime(totalTime)}`;
            timeline.value = animationTime;
            // DON'T sync back from action time - we control animationTime
        }

        function syncVideoToAnimation() {
            if (!videoDuration || !duration) return;

            // Map animation time to video time proportionally
            const videoTime = (animationTime / duration) * videoDuration;
            const clampedTime = Math.max(0, Math.min(videoTime, videoDuration - 0.01));

            // Only sync if difference is large (> 0.5s) to avoid stuttering
            // Let video play naturally for small differences
            const diff = Math.abs(video.currentTime - clampedTime);
            if (diff > 0.5) {
                video.currentTime = clampedTime;
            }
        }

        function syncAnimationToVideo() {
            // Only sync when NOT playing (user manually seeked video)
            if (!isPlaying && videoDuration && duration && mixer) {
                const videoProgress = video.currentTime / videoDuration;
                animationTime = Math.max(0, Math.min(videoProgress * duration, duration));
                mixer.setTime(animationTime);
                updateTimeDisplay();
            }
        }

        function play() {
            console.log('PLAY: videoDuration=', videoDuration, 'animDuration=', duration, 'video.duration=', video.duration);

            // Adjust video playback rate so video and animation stay in sync
            // If video is shorter, slow it down; if longer, speed it up
            if (videoDuration && duration) {
                const speedRatio = videoDuration / duration;
                const userSpeed = parseFloat(speedSelect.value);
                video.playbackRate = userSpeed * speedRatio;
                console.log('Video playback rate adjusted to:', video.playbackRate);
            }

            isPlaying = true;
            video.play().catch(e => console.warn('Video play error:', e));
            syncIndicator.classList.remove('off');
        }

        function pause() {
            isPlaying = false;
            video.pause();
        }

        function reset() {
            pause();
            animationTime = 0;
            if (mixer) {
                mixer.setTime(0);
            }
            video.currentTime = 0;
            updateTimeDisplay();
        }

        function setSpeed(speed) {
            // Adjust for duration ratio
            if (videoDuration && duration) {
                const speedRatio = videoDuration / duration;
                video.playbackRate = speed * speedRatio;
            } else {
                video.playbackRate = speed;
            }
        }

        function seekTo(time) {
            // Clamp to valid range
            animationTime = Math.max(0, Math.min(time, duration || time));

            // Reset lastTimestamp to avoid large delta jump on next play
            lastTimestamp = 0;

            // Update animation using setTime for reliable evaluation
            if (mixer) {
                mixer.setTime(animationTime);
            }

            // Update video directly
            if (videoDuration && duration) {
                const videoTime = (animationTime / duration) * videoDuration;
                video.currentTime = Math.max(0, Math.min(videoTime, videoDuration - 0.01));
                console.log('Video seeked to:', video.currentTime);
            }

            updateTimeDisplay();
        }

        // Track animation time manually for more control
        let animationTime = 0;
        let lastTimestamp = 0;
        let videoDuration = 0;  // Will be set once video loads

        // Animation loop - manually control time each frame
        function animate(timestamp) {
            requestAnimationFrame(animate);

            if (mixer && isPlaying && animationAction) {
                // Calculate delta time in seconds
                const delta = lastTimestamp ? (timestamp - lastTimestamp) / 1000 : 0;
                lastTimestamp = timestamp;

                // Apply playback speed
                const speed = parseFloat(speedSelect.value);
                animationTime += delta * speed;

                // Handle looping or stopping at end
                if (animationTime >= duration) {
                    if (isLooping) {
                        animationTime = animationTime % duration;
                    } else {
                        animationTime = duration;
                        pause();
                    }
                }

                // Use mixer.setTime() - works with all formats (GLB/FBX)
                // It resets internal time and re-evaluates at the given time
                mixer.setTime(animationTime);

                // Sync video and update display
                syncVideoToAnimation();
                updateTimeDisplay();
            } else {
                lastTimestamp = timestamp;
            }

            renderer.render(scene, camera);
        }

        // Event listeners
        playBtn.addEventListener('click', play);
        pauseBtn.addEventListener('click', pause);
        resetBtn.addEventListener('click', reset);

        speedSelect.addEventListener('change', (e) => {
            setSpeed(parseFloat(e.target.value));
        });

        timeline.addEventListener('input', (e) => {
            seekTo(parseFloat(e.target.value));
        });

        refreshBtn.addEventListener('click', loadLatestModel);

        loopBtn.addEventListener('click', () => {
            isLooping = !isLooping;
            loopBtn.textContent = isLooping ? 'üîÅ Loop: ON' : 'üîÅ Loop: OFF';
            video.loop = isLooping;
        });

        // Only sync animation to video when user manually seeks (not during playback)
        let userSeeking = false;
        video.addEventListener('seeking', () => {
            // User started seeking
            if (!isPlaying) userSeeking = true;
        });
        video.addEventListener('seeked', () => {
            if (userSeeking) {
                syncAnimationToVideo();
                userSeeking = false;
            }
        });
        video.addEventListener('play', () => {
            if (!isPlaying) play();
        });
        video.addEventListener('pause', () => {
            // Only pause animation if user explicitly paused (not video ending)
            // Check if video is near its end - if so, don't pause animation
            if (isPlaying && video.currentTime < videoDuration - 0.5) {
                pause();
            }
        });
        video.addEventListener('ended', () => {
            console.log('VIDEO ENDED at', video.currentTime, 'video duration:', video.duration, 'anim duration:', duration);
            // Video ended - DON'T let it reset animation time
            // Keep animation playing if it hasn't finished
            if (animationTime < duration - 0.5) {
                // Video is shorter than animation - keep animation playing
                console.log('Video shorter than animation, continuing animation');
            } else if (!isLooping) {
                pause();
            }
        });
        video.addEventListener('error', (e) => {
            console.error('VIDEO ERROR:', e);
        });
        video.addEventListener('loadedmetadata', () => {
            videoDuration = video.duration;
            console.log('Video loaded, duration:', videoDuration);
        });
        video.addEventListener('durationchange', () => {
            videoDuration = video.duration;
            console.log('Video duration changed to:', videoDuration);
        });

        // Initialize
        async function init() {
            initThree();
            animate();

            // Load video
            try {
                const videoResponse = await fetch('/api/video-path');
                const videoData = await videoResponse.json();
                if (videoData.path) {
                    video.src = videoData.path;
                    videoInfo.textContent = videoData.path.split('/').pop();
                }
            } catch (e) {
                // Fallback
                video.src = '/input/aitor_garden_walk.mp4';
                videoInfo.textContent = 'aitor_garden_walk.mp4';
            }

            // Load latest model (GLB)
            await loadLatestModel();
        }

        init();
    </script>
</body>
</html>
